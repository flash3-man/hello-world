# 数据治理与安全管理

## 🛡️ 数据治理框架

### 整体治理架构
```
┌─────────────────────────────────────────────────────────────┐
│                    数据治理委员会                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 数据负责人  │  │ 业务负责人  │  │ 技术负责人  │        │
│  │ CDO         │  │ Business    │  │ CTO         │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    治理执行层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 数据管理    │  │ 质量管理    │  │ 安全管理    │        │
│  │ Data Mgmt   │  │ Quality     │  │ Security    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 元数据管理  │  │ 生命周期    │  │ 合规管理    │        │
│  │ Metadata    │  │ Lifecycle   │  │ Compliance  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    技术支撑层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 数据目录    │  │ 血缘追踪    │  │ 质量监控    │        │
│  │ Catalog     │  │ Lineage     │  │ Monitor     │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 权限控制    │  │ 审计日志    │  │ 加密存储    │        │
│  │ Access      │  │ Audit       │  │ Encryption  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 数据治理策略

#### 1. 数据分类分级
```yaml
# 数据分类标准
data_classification:
  levels:
    - name: "公开数据"
      level: 1
      description: "可以公开发布的数据"
      examples: ["产品目录", "公司介绍", "行业报告"]
      protection_requirements:
        - "基础访问控制"
        - "标准备份"
      
    - name: "内部数据"
      level: 2
      description: "仅限内部使用的数据"
      examples: ["员工信息", "内部报表", "会议记录"]
      protection_requirements:
        - "身份认证"
        - "访问日志"
        - "定期备份"
      
    - name: "机密数据"
      level: 3
      description: "涉及商业机密的敏感数据"
      examples: ["财务数据", "客户信息", "销售数据"]
      protection_requirements:
        - "强身份认证"
        - "数据加密"
        - "访问审计"
        - "数据脱敏"
      
    - name: "绝密数据"
      level: 4
      description: "最高级别的敏感数据"
      examples: ["核心算法", "重大决策", "个人隐私"]
      protection_requirements:
        - "多因子认证"
        - "端到端加密"
        - "完整审计链"
        - "数据水印"
        - "定期安全评估"

  categories:
    - name: "个人信息"
      sensitive: true
      regulations: ["GDPR", "个人信息保护法"]
      fields: ["姓名", "身份证号", "手机号", "邮箱", "地址"]
      
    - name: "财务信息"
      sensitive: true
      regulations: ["SOX法案", "会计法"]
      fields: ["收入", "成本", "利润", "资产", "负债"]
      
    - name: "商业机密"
      sensitive: true
      regulations: ["商业秘密保护法"]
      fields: ["客户名单", "价格策略", "市场计划"]
```

#### 2. 数据标准化管理
```sql
-- 数据标准定义表
CREATE TABLE data_standards (
    standard_id String,
    standard_name String,
    category String,
    data_type String,
    format_rule String,
    validation_rule String,
    description String,
    examples Array(String),
    create_time DateTime,
    update_time DateTime,
    status Enum8('ACTIVE'=1, 'INACTIVE'=0)
) ENGINE = MergeTree()
ORDER BY (category, standard_name);

-- 插入标准数据
INSERT INTO data_standards VALUES
('STD_001', '客户编码标准', '客户管理', 'String', '^C[0-9]{8}$', 'length=9 AND startsWith(C)', '客户编码以C开头，后跟8位数字', ['C12345678'], now(), now(), 1),
('STD_002', '员工编码标准', '人力资源', 'String', '^E[0-9]{6}$', 'length=7 AND startsWith(E)', '员工编码以E开头，后跟6位数字', ['E123456'], now(), now(), 1),
('STD_003', '商品编码标准', '商品管理', 'String', '^P[0-9]{10}$', 'length=11 AND startsWith(P)', '商品编码以P开头，后跟10位数字', ['P1234567890'], now(), now(), 1),
('STD_004', '金额格式标准', '财务管理', 'Decimal', 'Decimal(15,2)', 'value >= 0', '金额保留2位小数，非负数', ['1234.56'], now(), now(), 1),
('STD_005', '日期格式标准', '通用', 'Date', 'YYYY-MM-DD', 'isValidDate', '标准日期格式', ['2024-08-14'], now(), now(), 1);

-- 数据质量规则表
CREATE TABLE data_quality_rules (
    rule_id String,
    rule_name String,
    table_name String,
    column_name String,
    rule_type Enum8('COMPLETENESS'=1, 'ACCURACY'=2, 'CONSISTENCY'=3, 'VALIDITY'=4),
    rule_expression String,
    threshold Decimal(5,4),
    severity Enum8('LOW'=1, 'MEDIUM'=2, 'HIGH'=3, 'CRITICAL'=4),
    description String,
    create_time DateTime,
    update_time DateTime,
    is_active UInt8 DEFAULT 1
) ENGINE = MergeTree()
ORDER BY (table_name, column_name, rule_type);

-- 插入质量规则
INSERT INTO data_quality_rules VALUES
('RULE_001', '客户名称完整性检查', 'dim_customer', 'customer_name', 1, 'customer_name IS NOT NULL AND customer_name != \'\'', 0.95, 3, '客户名称不能为空', now(), now(), 1),
('RULE_002', '订单金额准确性检查', 'fact_orders', 'order_amount', 2, 'order_amount > 0 AND order_amount < 1000000', 0.99, 3, '订单金额必须在合理范围内', now(), now(), 1),
('RULE_003', '员工部门一致性检查', 'dim_employee', 'department_id', 3, 'department_id IN (SELECT department_id FROM dim_department)', 1.0, 4, '员工部门必须存在于部门表中', now(), now(), 1);
```

## 🔐 数据安全架构

### 1. 访问控制体系

#### 基于角色的访问控制(RBAC)
```java
/**
 * 数据访问控制服务
 */
@Service
@Slf4j
public class DataAccessControlService {
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    @Autowired
    private RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    private DataClassificationService classificationService;
    
    /**
     * 检查数据访问权限
     */
    public boolean checkDataAccess(String userId, String resourcePath, String operation) {
        // 1. 获取用户角色
        List<String> userRoles = getUserRoles(userId);
        
        // 2. 获取资源的数据分类级别
        DataClassification classification = classificationService.getClassification(resourcePath);
        
        // 3. 检查角色权限
        for (String role : userRoles) {
            if (hasPermission(role, resourcePath, operation, classification)) {
                // 4. 记录访问日志
                logDataAccess(userId, resourcePath, operation, true);
                return true;
            }
        }
        
        // 5. 记录拒绝访问日志
        logDataAccess(userId, resourcePath, operation, false);
        return false;
    }
    
    /**
     * 动态数据脱敏
     */
    public Object maskSensitiveData(Object data, String userId, DataClassification classification) {
        if (classification.getLevel() <= 2) {
            return data; // 公开和内部数据不脱敏
        }
        
        // 获取用户的脱敏权限
        Set<String> unmaskFields = getUnmaskPermissions(userId);
        
        if (data instanceof Map) {
            Map<String, Object> maskedData = new HashMap<>();
            Map<String, Object> originalData = (Map<String, Object>) data;
            
            for (Map.Entry<String, Object> entry : originalData.entrySet()) {
                String fieldName = entry.getKey();
                Object fieldValue = entry.getValue();
                
                if (isSensitiveField(fieldName) && !unmaskFields.contains(fieldName)) {
                    maskedData.put(fieldName, maskFieldValue(fieldName, fieldValue));
                } else {
                    maskedData.put(fieldName, fieldValue);
                }
            }
            
            return maskedData;
        }
        
        return data;
    }
    
    private Object maskFieldValue(String fieldName, Object value) {
        if (value == null) return null;
        
        String strValue = value.toString();
        
        switch (fieldName.toLowerCase()) {
            case "phone":
            case "mobile":
                return maskPhone(strValue);
            case "email":
                return maskEmail(strValue);
            case "idcard":
            case "id_card":
                return maskIdCard(strValue);
            case "bankcard":
            case "bank_card":
                return maskBankCard(strValue);
            case "name":
            case "customer_name":
                return maskName(strValue);
            default:
                return "***";
        }
    }
    
    private String maskPhone(String phone) {
        if (phone.length() >= 11) {
            return phone.substring(0, 3) + "****" + phone.substring(7);
        }
        return "***";
    }
    
    private String maskEmail(String email) {
        int atIndex = email.indexOf('@');
        if (atIndex > 0) {
            String prefix = email.substring(0, Math.min(3, atIndex));
            String suffix = email.substring(atIndex);
            return prefix + "***" + suffix;
        }
        return "***";
    }
    
    private String maskIdCard(String idCard) {
        if (idCard.length() >= 18) {
            return idCard.substring(0, 6) + "********" + idCard.substring(14);
        }
        return "***";
    }
    
    private String maskName(String name) {
        if (name.length() <= 1) {
            return "*";
        } else if (name.length() == 2) {
            return name.charAt(0) + "*";
        } else {
            return name.charAt(0) + "*".repeat(name.length() - 2) + name.charAt(name.length() - 1);
        }
    }
}

/**
 * 行级数据安全策略
 */
@Component
public class RowLevelSecurityPolicy {
    
    /**
     * 构建行级安全过滤条件
     */
    public String buildSecurityFilter(String userId, String tableName) {
        UserContext userContext = getCurrentUserContext(userId);
        
        switch (tableName) {
            case "fact_sales":
                return buildSalesSecurityFilter(userContext);
            case "dim_customer":
                return buildCustomerSecurityFilter(userContext);
            case "dim_employee":
                return buildEmployeeSecurityFilter(userContext);
            default:
                return "1=1"; // 默认无限制
        }
    }
    
    private String buildSalesSecurityFilter(UserContext userContext) {
        if (userContext.hasRole("ADMIN")) {
            return "1=1"; // 管理员可以看所有数据
        } else if (userContext.hasRole("MANAGER")) {
            // 经理可以看本部门数据
            return String.format("department_id = '%s'", userContext.getDepartmentId());
        } else if (userContext.hasRole("EMPLOYEE")) {
            // 员工只能看自己的数据
            return String.format("employee_id = '%s'", userContext.getEmployeeId());
        } else {
            return "1=0"; // 无权限
        }
    }
    
    private String buildCustomerSecurityFilter(UserContext userContext) {
        if (userContext.hasRole("ADMIN") || userContext.hasRole("MANAGER")) {
            return "1=1";
        } else {
            // 普通员工只能看到自己负责的客户
            return String.format("responsible_employee_id = '%s'", userContext.getEmployeeId());
        }
    }
}
```

### 2. 数据加密策略

#### 多层加密架构
```java
/**
 * 数据加密服务
 */
@Service
@Slf4j
public class DataEncryptionService {
    
    private static final String AES_ALGORITHM = "AES/GCM/NoPadding";
    private static final String RSA_ALGORITHM = "RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING";
    
    @Autowired
    private KeyManagementService keyManagementService;
    
    /**
     * 字段级加密
     */
    public String encryptField(String plaintext, String fieldName, String keyId) {
        try {
            // 获取字段加密密钥
            SecretKey fieldKey = keyManagementService.getFieldKey(keyId);
            
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, fieldKey);
            
            byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
            byte[] iv = cipher.getIV();
            
            // 组合IV和密文
            byte[] combined = new byte[iv.length + encryptedBytes.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
            
            return Base64.getEncoder().encodeToString(combined);
            
        } catch (Exception e) {
            log.error("字段加密失败: {}", e.getMessage(), e);
            throw new SecurityException("数据加密失败");
        }
    }
    
    /**
     * 字段级解密
     */
    public String decryptField(String ciphertext, String fieldName, String keyId) {
        try {
            byte[] combined = Base64.getDecoder().decode(ciphertext);
            
            // 分离IV和密文
            byte[] iv = new byte[12]; // GCM模式IV长度为12字节
            byte[] encryptedBytes = new byte[combined.length - 12];
            System.arraycopy(combined, 0, iv, 0, 12);
            System.arraycopy(combined, 12, encryptedBytes, 0, encryptedBytes.length);
            
            SecretKey fieldKey = keyManagementService.getFieldKey(keyId);
            
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.DECRYPT_MODE, fieldKey, gcmSpec);
            
            byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
            return new String(decryptedBytes, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            log.error("字段解密失败: {}", e.getMessage(), e);
            throw new SecurityException("数据解密失败");
        }
    }
    
    /**
     * 文件级加密
     */
    public void encryptFile(String inputFilePath, String outputFilePath, String keyId) {
        try (FileInputStream fis = new FileInputStream(inputFilePath);
             FileOutputStream fos = new FileOutputStream(outputFilePath)) {
            
            SecretKey fileKey = keyManagementService.getFileKey(keyId);
            
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, fileKey);
            
            // 写入IV
            byte[] iv = cipher.getIV();
            fos.write(iv);
            
            // 加密文件内容
            try (CipherOutputStream cos = new CipherOutputStream(fos, cipher)) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = fis.read(buffer)) != -1) {
                    cos.write(buffer, 0, bytesRead);
                }
            }
            
            log.info("文件加密完成: {} -> {}", inputFilePath, outputFilePath);
            
        } catch (Exception e) {
            log.error("文件加密失败: {}", e.getMessage(), e);
            throw new SecurityException("文件加密失败");
        }
    }
}

/**
 * 密钥管理服务
 */
@Service
@Slf4j
public class KeyManagementService {
    
    @Autowired
    private HSMClient hsmClient; // 硬件安全模块客户端
    
    private final Map<String, SecretKey> keyCache = new ConcurrentHashMap<>();
    
    /**
     * 获取字段加密密钥
     */
    public SecretKey getFieldKey(String keyId) {
        return keyCache.computeIfAbsent(keyId, this::loadFieldKeyFromHSM);
    }
    
    /**
     * 密钥轮换
     */
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void rotateKeys() {
        log.info("开始执行密钥轮换");
        
        try {
            // 生成新的主密钥
            String newMasterKeyId = hsmClient.generateMasterKey();
            
            // 重新加密所有字段密钥
            reencryptFieldKeys(newMasterKeyId);
            
            // 更新密钥版本
            updateKeyVersion(newMasterKeyId);
            
            // 清理缓存
            keyCache.clear();
            
            log.info("密钥轮换完成，新主密钥ID: {}", newMasterKeyId);
            
        } catch (Exception e) {
            log.error("密钥轮换失败: {}", e.getMessage(), e);
            // 发送告警
            alertService.sendAlert("密钥轮换失败", e.getMessage());
        }
    }
    
    private SecretKey loadFieldKeyFromHSM(String keyId) {
        try {
            return hsmClient.getKey(keyId);
        } catch (Exception e) {
            log.error("从HSM加载密钥失败: {}", e.getMessage(), e);
            throw new SecurityException("密钥加载失败");
        }
    }
}
```

### 3. 审计日志系统

#### 审计日志设计
```sql
-- 数据访问审计日志表
CREATE TABLE audit_data_access (
    log_id String,
    user_id String,
    user_name String,
    session_id String,
    access_time DateTime,
    resource_type String,
    resource_path String,
    operation String,
    access_result Enum8('SUCCESS'=1, 'DENIED'=2, 'ERROR'=3),
    ip_address String,
    user_agent String,
    request_params String,
    response_size UInt64,
    execution_time UInt32,
    error_message String,
    risk_score UInt8,
    create_time DateTime DEFAULT now()
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(access_time)
ORDER BY (user_id, access_time)
TTL access_time + INTERVAL 2 YEAR;

-- 数据变更审计日志表
CREATE TABLE audit_data_changes (
    log_id String,
    user_id String,
    user_name String,
    change_time DateTime,
    table_name String,
    operation_type Enum8('INSERT'=1, 'UPDATE'=2, 'DELETE'=3),
    record_id String,
    old_values String,
    new_values String,
    change_reason String,
    approval_status Enum8('PENDING'=1, 'APPROVED'=2, 'REJECTED'=3),
    approver_id String,
    create_time DateTime DEFAULT now()
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(change_time)
ORDER BY (table_name, change_time)
TTL change_time + INTERVAL 7 YEAR;

-- 系统安全事件日志表
CREATE TABLE audit_security_events (
    event_id String,
    event_type String,
    event_time DateTime,
    severity Enum8('LOW'=1, 'MEDIUM'=2, 'HIGH'=3, 'CRITICAL'=4),
    source_ip String,
    user_id String,
    event_description String,
    event_details String,
    handled UInt8 DEFAULT 0,
    handler_id String,
    handle_time DateTime,
    create_time DateTime DEFAULT now()
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(event_time)
ORDER BY (event_type, event_time)
TTL event_time + INTERVAL 5 YEAR;
```

#### 审计日志分析
```java
/**
 * 审计日志分析服务
 */
@Service
@Slf4j
public class AuditAnalysisService {
    
    @Autowired
    private ClickHouseTemplate clickHouseTemplate;
    
    @Autowired
    private AlertService alertService;
    
    /**
     * 异常访问行为检测
     */
    @Scheduled(fixedRate = 300000) // 每5分钟执行一次
    public void detectAnomalousAccess() {
        // 1. 检测异常访问频率
        detectHighFrequencyAccess();
        
        // 2. 检测异常访问时间
        detectOffHoursAccess();
        
        // 3. 检测异常访问地点
        detectUnusualLocationAccess();
        
        // 4. 检测权限提升尝试
        detectPrivilegeEscalation();
    }
    
    private void detectHighFrequencyAccess() {
        String sql = """
            SELECT 
                user_id,
                user_name,
                count() as access_count,
                uniq(resource_path) as unique_resources
            FROM audit_data_access
            WHERE access_time >= now() - INTERVAL 1 HOUR
            GROUP BY user_id, user_name
            HAVING access_count > 1000 OR unique_resources > 100
            ORDER BY access_count DESC
            """;
        
        List<Map<String, Object>> results = clickHouseTemplate.queryForList(sql);
        
        for (Map<String, Object> result : results) {
            String userId = (String) result.get("user_id");
            String userName = (String) result.get("user_name");
            Long accessCount = (Long) result.get("access_count");
            
            SecurityEvent event = SecurityEvent.builder()
                .eventType("HIGH_FREQUENCY_ACCESS")
                .severity(SecuritySeverity.HIGH)
                .userId(userId)
                .description(String.format("用户 %s 在1小时内访问了 %d 次数据", userName, accessCount))
                .build();
            
            handleSecurityEvent(event);
        }
    }
    
    private void detectOffHoursAccess() {
        String sql = """
            SELECT 
                user_id,
                user_name,
                count() as access_count,
                groupArray(resource_path) as accessed_resources
            FROM audit_data_access
            WHERE access_time >= today()
              AND (toHour(access_time) < 8 OR toHour(access_time) > 22)
              AND resource_type = 'SENSITIVE_DATA'
            GROUP BY user_id, user_name
            HAVING access_count > 10
            """;
        
        List<Map<String, Object>> results = clickHouseTemplate.queryForList(sql);
        
        for (Map<String, Object> result : results) {
            SecurityEvent event = SecurityEvent.builder()
                .eventType("OFF_HOURS_ACCESS")
                .severity(SecuritySeverity.MEDIUM)
                .userId((String) result.get("user_id"))
                .description("非工作时间访问敏感数据")
                .build();
            
            handleSecurityEvent(event);
        }
    }
    
    /**
     * 生成合规报告
     */
    public ComplianceReport generateComplianceReport(String reportType, LocalDate startDate, LocalDate endDate) {
        switch (reportType) {
            case "GDPR":
                return generateGDPRReport(startDate, endDate);
            case "SOX":
                return generateSOXReport(startDate, endDate);
            case "PERSONAL_INFO":
                return generatePersonalInfoReport(startDate, endDate);
            default:
                throw new IllegalArgumentException("不支持的报告类型: " + reportType);
        }
    }
    
    private ComplianceReport generateGDPRReport(LocalDate startDate, LocalDate endDate) {
        // GDPR合规报告
        String sql = """
            SELECT 
                'personal_data_access' as metric_name,
                count() as metric_value,
                'Total personal data access requests' as description
            FROM audit_data_access
            WHERE access_time BETWEEN ? AND ?
              AND resource_path LIKE '%personal%'
            
            UNION ALL
            
            SELECT 
                'data_subject_requests' as metric_name,
                count() as metric_value,
                'Data subject access requests' as description
            FROM audit_data_access
            WHERE access_time BETWEEN ? AND ?
              AND operation = 'DATA_SUBJECT_REQUEST'
            """;
        
        List<Map<String, Object>> metrics = clickHouseTemplate.queryForList(sql, 
            startDate, endDate, startDate, endDate);
        
        return ComplianceReport.builder()
            .reportType("GDPR")
            .startDate(startDate)
            .endDate(endDate)
            .metrics(metrics)
            .generateTime(LocalDateTime.now())
            .build();
    }
    
    private void handleSecurityEvent(SecurityEvent event) {
        // 记录安全事件
        logSecurityEvent(event);
        
        // 发送告警
        if (event.getSeverity().ordinal() >= SecuritySeverity.HIGH.ordinal()) {
            alertService.sendSecurityAlert(event);
        }
        
        // 自动响应
        if (event.getSeverity() == SecuritySeverity.CRITICAL) {
            autoResponseToThreat(event);
        }
    }
    
    private void autoResponseToThreat(SecurityEvent event) {
        switch (event.getEventType()) {
            case "HIGH_FREQUENCY_ACCESS":
                // 临时限制用户访问频率
                rateLimitService.limitUser(event.getUserId(), Duration.ofHours(1));
                break;
            case "PRIVILEGE_ESCALATION":
                // 临时禁用用户账户
                userService.temporaryDisableUser(event.getUserId(), Duration.ofHours(24));
                break;
            case "DATA_EXFILTRATION":
                // 阻止用户数据导出
                dataExportService.blockUser(event.getUserId());
                break;
        }
    }
}
```

---

**文档版本**: v1.0  
**最后更新**: 2024年8月14日  
**维护团队**: 数据治理团队  

> 🛡️ **安全提醒**: 数据治理和安全管理是一个持续的过程，需要定期评估和更新策略。本文档提供了完整的治理框架和技术实现方案，在实际应用中请根据具体的合规要求和安全威胁进行调整。
