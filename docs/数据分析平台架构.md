# 数据分析平台架构设计

## 🏗️ 整体架构概览

### 分层架构设计
```
┌─────────────────────────────────────────────────────────────┐
│                    展示层 (Presentation Layer)              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 移动端APP   │  │ Web管理端   │  │ 大屏展示    │        │
│  │ Vue3+Vant   │  │ React+Ant   │  │ DataV       │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 分析服务    │  │ 报表服务    │  │ 告警服务    │        │
│  │ Analysis    │  │ Report      │  │ Alert       │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 用户服务    │  │ 权限服务    │  │ 配置服务    │        │
│  │ User        │  │ Auth        │  │ Config      │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    数据服务层 (Data Service Layer)          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ OLAP查询    │  │ 实时计算    │  │ 机器学习    │        │
│  │ ClickHouse  │  │ Flink       │  │ MLflow      │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 缓存服务    │  │ 搜索服务    │  │ 图数据库    │        │
│  │ Redis       │  │ Elasticsearch│ │ Neo4j       │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    数据存储层 (Storage Layer)                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 数据仓库    │  │ 数据湖      │  │ 关系数据库  │        │
│  │ ClickHouse  │  │ HDFS/S3     │  │ MySQL       │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    基础设施层 (Infrastructure Layer)         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 容器编排    │  │ 服务网格    │  │ 监控告警    │        │
│  │ Kubernetes  │  │ Istio       │  │ Prometheus  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

## 🔧 核心组件设计

### 1. 分析引擎架构

#### OLAP查询引擎
```yaml
# ClickHouse集群配置
clickhouse_cluster:
  name: "business_analysis_cluster"
  nodes:
    - host: "clickhouse-01"
      port: 9000
      role: "shard1_replica1"
    - host: "clickhouse-02"
      port: 9000
      role: "shard1_replica2"
    - host: "clickhouse-03"
      port: 9000
      role: "shard2_replica1"
    - host: "clickhouse-04"
      port: 9000
      role: "shard2_replica2"
  
  settings:
    max_memory_usage: "10000000000"  # 10GB
    max_execution_time: 300          # 5分钟
    max_concurrent_queries: 100
    
  optimization:
    enable_parallel_processing: true
    enable_distributed_aggregation: true
    enable_query_cache: true
    cache_size: "5GB"
```

#### 实时计算引擎
```yaml
# Flink集群配置
flink_cluster:
  jobmanager:
    replicas: 2
    memory: "2048m"
    cpu: "1000m"
  
  taskmanager:
    replicas: 6
    memory: "4096m"
    cpu: "2000m"
    slots: 4
  
  checkpointing:
    interval: 60000
    timeout: 600000
    min_pause_between: 5000
    max_concurrent: 1
    
  state_backend:
    type: "rocksdb"
    incremental: true
    
  jobs:
    - name: "realtime_sales_aggregation"
      parallelism: 12
      source: "kafka_sales_events"
      sink: "clickhouse_rt_metrics"
    
    - name: "realtime_alert_detection"
      parallelism: 6
      source: "kafka_business_events"
      sink: "alert_notification_service"
```

### 2. 数据服务API设计

#### 查询服务接口
```java
/**
 * 数据查询服务
 */
@RestController
@RequestMapping("/api/v1/query")
@Slf4j
public class DataQueryController {
    
    @Autowired
    private AnalyticsQueryService queryService;
    
    /**
     * 多维分析查询
     */
    @PostMapping("/multidimensional")
    public Result<QueryResult> multidimensionalQuery(@RequestBody QueryRequest request) {
        log.info("执行多维分析查询: {}", request);
        
        // 参数验证
        validateQueryRequest(request);
        
        // 查询优化
        QueryPlan optimizedPlan = queryService.optimizeQuery(request);
        
        // 执行查询
        QueryResult result = queryService.executeQuery(optimizedPlan);
        
        // 结果缓存
        cacheQueryResult(request, result);
        
        return Result.success(result);
    }
    
    /**
     * 实时指标查询
     */
    @GetMapping("/realtime/{metricType}")
    public Result<RealtimeMetrics> getRealtimeMetrics(
            @PathVariable String metricType,
            @RequestParam(defaultValue = "1h") String timeWindow) {
        
        log.info("查询实时指标: {}, 时间窗口: {}", metricType, timeWindow);
        
        RealtimeMetrics metrics = queryService.getRealtimeMetrics(metricType, timeWindow);
        
        return Result.success(metrics);
    }
    
    /**
     * 趋势分析查询
     */
    @PostMapping("/trend")
    public Result<TrendAnalysisResult> trendAnalysis(@RequestBody TrendQueryRequest request) {
        log.info("执行趋势分析: {}", request);
        
        // 时间序列分析
        TrendAnalysisResult result = queryService.analyzeTrend(request);
        
        return Result.success(result);
    }
}

/**
 * 查询请求模型
 */
@Data
public class QueryRequest {
    private String queryType;           // 查询类型
    private List<String> dimensions;    // 维度字段
    private List<String> metrics;       // 指标字段
    private List<FilterCondition> filters; // 过滤条件
    private List<SortCondition> sorts;  // 排序条件
    private TimeRange timeRange;        // 时间范围
    private Integer limit;              // 结果限制
    private Boolean enableCache;        // 是否启用缓存
}

/**
 * 查询结果模型
 */
@Data
public class QueryResult {
    private List<Map<String, Object>> data;    // 查询数据
    private QueryMetadata metadata;            // 查询元数据
    private Long totalCount;                   // 总记录数
    private Long executionTime;                // 执行时间(ms)
    private String queryId;                    // 查询ID
    private Boolean fromCache;                 // 是否来自缓存
}
```

#### 分析服务实现
```java
/**
 * 分析查询服务实现
 */
@Service
@Slf4j
public class AnalyticsQueryServiceImpl implements AnalyticsQueryService {
    
    @Autowired
    private ClickHouseTemplate clickHouseTemplate;
    
    @Autowired
    private QueryOptimizer queryOptimizer;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public QueryResult executeQuery(QueryPlan queryPlan) {
        String sql = queryPlan.getSql();
        Map<String, Object> parameters = queryPlan.getParameters();
        
        log.debug("执行SQL查询: {}", sql);
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 执行查询
            List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql, parameters);
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            // 构建查询结果
            QueryResult result = QueryResult.builder()
                .data(data)
                .totalCount((long) data.size())
                .executionTime(executionTime)
                .queryId(UUID.randomUUID().toString())
                .fromCache(false)
                .build();
            
            log.info("查询执行完成，耗时: {}ms，返回记录数: {}", executionTime, data.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查询执行失败: {}", e.getMessage(), e);
            throw new BusinessException(ErrorCode.QUERY_EXECUTION_ERROR, "查询执行失败");
        }
    }
    
    @Override
    public RealtimeMetrics getRealtimeMetrics(String metricType, String timeWindow) {
        String cacheKey = String.format("realtime:%s:%s", metricType, timeWindow);
        
        // 尝试从缓存获取
        RealtimeMetrics cached = cacheManager.get(cacheKey, RealtimeMetrics.class);
        if (cached != null) {
            return cached;
        }
        
        // 从实时数据源查询
        String sql = buildRealtimeMetricsSql(metricType, timeWindow);
        List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql);
        
        RealtimeMetrics metrics = convertToRealtimeMetrics(data, metricType);
        
        // 缓存结果（短期缓存）
        cacheManager.put(cacheKey, metrics, Duration.ofMinutes(1));
        
        return metrics;
    }
    
    @Override
    public TrendAnalysisResult analyzeTrend(TrendQueryRequest request) {
        // 构建趋势分析SQL
        String sql = buildTrendAnalysisSql(request);
        
        List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql);
        
        // 时间序列分析
        TimeSeriesAnalyzer analyzer = new TimeSeriesAnalyzer();
        TrendAnalysisResult result = analyzer.analyze(data, request);
        
        return result;
    }
    
    private String buildRealtimeMetricsSql(String metricType, String timeWindow) {
        switch (metricType) {
            case "sales":
                return String.format("""
                    SELECT 
                        toStartOfInterval(event_time, INTERVAL %s) as time_bucket,
                        sum(amount) as total_amount,
                        count() as event_count,
                        uniq(customer_id) as unique_customers
                    FROM rt_sales_events
                    WHERE event_time >= now() - INTERVAL %s
                    GROUP BY time_bucket
                    ORDER BY time_bucket
                    """, timeWindow, timeWindow);
                    
            case "orders":
                return String.format("""
                    SELECT 
                        toStartOfInterval(event_time, INTERVAL %s) as time_bucket,
                        count() as order_count,
                        sum(order_amount) as total_amount,
                        avg(order_amount) as avg_amount
                    FROM rt_order_events
                    WHERE event_time >= now() - INTERVAL %s
                    GROUP BY time_bucket
                    ORDER BY time_bucket
                    """, timeWindow, timeWindow);
                    
            default:
                throw new BusinessException(ErrorCode.INVALID_METRIC_TYPE, "不支持的指标类型: " + metricType);
        }
    }
}
```

### 3. 缓存策略设计

#### 多级缓存架构
```java
/**
 * 多级缓存管理器
 */
@Component
@Slf4j
public class MultiLevelCacheManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final Cache<String, Object> localCache;
    
    public MultiLevelCacheManager() {
        // 本地缓存配置
        this.localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(Duration.ofMinutes(5))
            .recordStats()
            .build();
    }
    
    /**
     * 获取缓存数据
     */
    public <T> T get(String key, Class<T> type) {
        // 1. 先查本地缓存
        Object localValue = localCache.getIfPresent(key);
        if (localValue != null) {
            log.debug("命中本地缓存: {}", key);
            return type.cast(localValue);
        }
        
        // 2. 查Redis缓存
        Object redisValue = redisTemplate.opsForValue().get(key);
        if (redisValue != null) {
            log.debug("命中Redis缓存: {}", key);
            // 回写本地缓存
            localCache.put(key, redisValue);
            return type.cast(redisValue);
        }
        
        log.debug("缓存未命中: {}", key);
        return null;
    }
    
    /**
     * 设置缓存数据
     */
    public void put(String key, Object value, Duration expiration) {
        // 同时写入本地缓存和Redis
        localCache.put(key, value);
        redisTemplate.opsForValue().set(key, value, expiration);
        
        log.debug("设置缓存: {}, 过期时间: {}", key, expiration);
    }
    
    /**
     * 删除缓存
     */
    public void evict(String key) {
        localCache.invalidate(key);
        redisTemplate.delete(key);
        
        log.debug("删除缓存: {}", key);
    }
    
    /**
     * 批量删除缓存
     */
    public void evictByPattern(String pattern) {
        // 删除Redis中匹配的key
        Set<String> keys = redisTemplate.keys(pattern);
        if (!keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
        
        // 清空本地缓存（简单处理）
        localCache.invalidateAll();
        
        log.debug("批量删除缓存，模式: {}, 删除数量: {}", pattern, keys.size());
    }
}

/**
 * 查询结果缓存策略
 */
@Component
public class QueryCacheStrategy {
    
    @Autowired
    private MultiLevelCacheManager cacheManager;
    
    /**
     * 生成缓存key
     */
    public String generateCacheKey(QueryRequest request) {
        // 使用查询参数的hash作为缓存key
        String content = JSON.toJSONString(request);
        return "query:" + DigestUtils.md5Hex(content);
    }
    
    /**
     * 确定缓存过期时间
     */
    public Duration determineCacheExpiration(QueryRequest request) {
        // 根据查询类型和时间范围确定缓存时间
        if (request.getTimeRange().isRealtime()) {
            return Duration.ofMinutes(1);  // 实时查询缓存1分钟
        } else if (request.getTimeRange().isToday()) {
            return Duration.ofMinutes(10); // 当日查询缓存10分钟
        } else if (request.getTimeRange().isHistorical()) {
            return Duration.ofHours(1);    // 历史查询缓存1小时
        } else {
            return Duration.ofMinutes(30); // 默认缓存30分钟
        }
    }
    
    /**
     * 判断是否应该缓存
     */
    public boolean shouldCache(QueryRequest request, QueryResult result) {
        // 查询时间超过1秒的结果才缓存
        if (result.getExecutionTime() < 1000) {
            return false;
        }
        
        // 结果集太大不缓存
        if (result.getTotalCount() > 10000) {
            return false;
        }
        
        // 实时查询不缓存
        if (request.getQueryType().equals("realtime")) {
            return false;
        }
        
        return true;
    }
}
```

### 4. 性能监控与优化

#### 查询性能监控
```java
/**
 * 查询性能监控
 */
@Component
@Slf4j
public class QueryPerformanceMonitor {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Timer queryTimer;
    private final Counter queryCounter;
    private final Gauge slowQueryGauge;
    
    public QueryPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.queryTimer = Timer.builder("query.execution.time")
            .description("查询执行时间")
            .register(meterRegistry);
        this.queryCounter = Counter.builder("query.total")
            .description("查询总数")
            .register(meterRegistry);
        this.slowQueryGauge = Gauge.builder("query.slow.count")
            .description("慢查询数量")
            .register(meterRegistry, this, QueryPerformanceMonitor::getSlowQueryCount);
    }
    
    /**
     * 记录查询性能
     */
    public void recordQueryPerformance(String queryType, long executionTime, boolean success) {
        // 记录查询时间
        queryTimer.record(executionTime, TimeUnit.MILLISECONDS);
        
        // 记录查询次数
        queryCounter.increment(
            Tags.of(
                "type", queryType,
                "status", success ? "success" : "failure"
            )
        );
        
        // 记录慢查询
        if (executionTime > 5000) { // 超过5秒的查询
            recordSlowQuery(queryType, executionTime);
        }
        
        log.info("查询性能记录 - 类型: {}, 耗时: {}ms, 状态: {}", 
            queryType, executionTime, success ? "成功" : "失败");
    }
    
    private void recordSlowQuery(String queryType, long executionTime) {
        // 记录慢查询到数据库或日志
        log.warn("慢查询告警 - 类型: {}, 耗时: {}ms", queryType, executionTime);
        
        // 发送告警
        sendSlowQueryAlert(queryType, executionTime);
    }
    
    private void sendSlowQueryAlert(String queryType, long executionTime) {
        // 发送告警通知
        AlertMessage alert = AlertMessage.builder()
            .title("慢查询告警")
            .content(String.format("查询类型: %s, 执行时间: %dms", queryType, executionTime))
            .level(AlertLevel.WARNING)
            .build();
            
        alertService.sendAlert(alert);
    }
    
    private double getSlowQueryCount() {
        // 返回最近1小时的慢查询数量
        return slowQueryRepository.countByTimeRange(
            LocalDateTime.now().minusHours(1),
            LocalDateTime.now()
        );
    }
}
```

## 📊 数据可视化架构

### 1. 图表组件设计

#### 通用图表配置
```typescript
// 图表配置接口
interface ChartConfig {
  type: ChartType;
  title: string;
  data: ChartData;
  options: ChartOptions;
  interactions?: ChartInteraction[];
}

// 图表类型枚举
enum ChartType {
  LINE = 'line',
  BAR = 'bar',
  PIE = 'pie',
  SCATTER = 'scatter',
  HEATMAP = 'heatmap',
  GAUGE = 'gauge',
  FUNNEL = 'funnel',
  RADAR = 'radar'
}

// 图表数据结构
interface ChartData {
  dimensions: string[];
  measures: string[];
  dataset: Record<string, any>[];
  aggregations?: Aggregation[];
}

// 图表选项
interface ChartOptions {
  width?: number;
  height?: number;
  theme?: string;
  animation?: boolean;
  responsive?: boolean;
  legend?: LegendConfig;
  tooltip?: TooltipConfig;
  axis?: AxisConfig;
  colors?: string[];
}
```

#### 图表组件实现
```vue
<!-- 通用图表组件 -->
<template>
  <div class="chart-container" :style="containerStyle">
    <div class="chart-header" v-if="config.title">
      <h3 class="chart-title">{{ config.title }}</h3>
      <div class="chart-actions">
        <button @click="refreshChart" class="action-btn">
          <RefreshIcon />
        </button>
        <button @click="exportChart" class="action-btn">
          <DownloadIcon />
        </button>
        <button @click="fullscreen" class="action-btn">
          <FullscreenIcon />
        </button>
      </div>
    </div>
    
    <div 
      ref="chartRef" 
      class="chart-content"
      :style="chartStyle"
    ></div>
    
    <div class="chart-loading" v-if="loading">
      <LoadingSpinner />
      <span>数据加载中...</span>
    </div>
    
    <div class="chart-error" v-if="error">
      <ErrorIcon />
      <span>{{ error }}</span>
      <button @click="retryLoad" class="retry-btn">重试</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, computed } from 'vue'
import * as echarts from 'echarts'
import type { ChartConfig } from '@/types/chart'

interface Props {
  config: ChartConfig
  loading?: boolean
  error?: string
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  error: ''
})

const emit = defineEmits<{
  refresh: []
  export: [format: string]
  interact: [event: any]
}>()

const chartRef = ref<HTMLElement>()
const chartInstance = ref<echarts.ECharts>()

const containerStyle = computed(() => ({
  width: props.config.options?.width ? `${props.config.options.width}px` : '100%',
  height: props.config.options?.height ? `${props.config.options.height}px` : '400px'
}))

const chartStyle = computed(() => ({
  width: '100%',
  height: props.config.title ? 'calc(100% - 40px)' : '100%'
}))

onMounted(() => {
  initChart()
})

watch(() => props.config, () => {
  updateChart()
}, { deep: true })

function initChart() {
  if (!chartRef.value) return
  
  chartInstance.value = echarts.init(chartRef.value, props.config.options?.theme)
  
  // 添加交互事件
  chartInstance.value.on('click', (params) => {
    emit('interact', { type: 'click', params })
  })
  
  chartInstance.value.on('legendselectchanged', (params) => {
    emit('interact', { type: 'legendChange', params })
  })
  
  updateChart()
}

function updateChart() {
  if (!chartInstance.value) return
  
  const option = buildChartOption(props.config)
  chartInstance.value.setOption(option, true)
}

function buildChartOption(config: ChartConfig) {
  const baseOption = {
    title: {
      text: config.title,
      left: 'center'
    },
    tooltip: {
      trigger: 'axis',
      ...config.options?.tooltip
    },
    legend: {
      type: 'scroll',
      bottom: 0,
      ...config.options?.legend
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '10%',
      containLabel: true
    },
    animation: config.options?.animation !== false
  }
  
  // 根据图表类型构建特定配置
  switch (config.type) {
    case ChartType.LINE:
      return buildLineChartOption(config, baseOption)
    case ChartType.BAR:
      return buildBarChartOption(config, baseOption)
    case ChartType.PIE:
      return buildPieChartOption(config, baseOption)
    default:
      return baseOption
  }
}

function buildLineChartOption(config: ChartConfig, baseOption: any) {
  return {
    ...baseOption,
    xAxis: {
      type: 'category',
      data: config.data.dimensions,
      ...config.options?.axis?.x
    },
    yAxis: {
      type: 'value',
      ...config.options?.axis?.y
    },
    series: config.data.measures.map(measure => ({
      name: measure,
      type: 'line',
      data: config.data.dataset.map(item => item[measure]),
      smooth: true,
      symbol: 'circle',
      symbolSize: 6
    }))
  }
}

function refreshChart() {
  emit('refresh')
}

function exportChart() {
  if (!chartInstance.value) return
  
  const dataURL = chartInstance.value.getDataURL({
    type: 'png',
    pixelRatio: 2,
    backgroundColor: '#fff'
  })
  
  emit('export', dataURL)
}

function fullscreen() {
  // 全屏显示逻辑
}

function retryLoad() {
  emit('refresh')
}
</script>
```

### 2. 仪表板设计

#### 仪表板配置
```typescript
// 仪表板配置
interface DashboardConfig {
  id: string
  name: string
  description?: string
  layout: LayoutConfig
  widgets: WidgetConfig[]
  filters?: FilterConfig[]
  refresh?: RefreshConfig
  permissions?: PermissionConfig
}

// 布局配置
interface LayoutConfig {
  type: 'grid' | 'flex' | 'absolute'
  columns: number
  gap: number
  responsive: boolean
}

// 组件配置
interface WidgetConfig {
  id: string
  type: WidgetType
  title: string
  position: Position
  size: Size
  dataSource: DataSourceConfig
  chartConfig: ChartConfig
  interactions?: InteractionConfig[]
}

// 数据源配置
interface DataSourceConfig {
  type: 'api' | 'websocket' | 'static'
  url?: string
  method?: string
  params?: Record<string, any>
  headers?: Record<string, string>
  refresh?: number // 刷新间隔(秒)
}
```

#### 仪表板组件
```vue
<!-- 仪表板组件 -->
<template>
  <div class="dashboard" :class="dashboardClass">
    <!-- 仪表板头部 -->
    <div class="dashboard-header">
      <div class="dashboard-title">
        <h2>{{ config.name }}</h2>
        <p v-if="config.description">{{ config.description }}</p>
      </div>
      
      <div class="dashboard-actions">
        <!-- 全局筛选器 -->
        <div class="global-filters" v-if="config.filters">
          <FilterPanel 
            :filters="config.filters"
            @change="handleFilterChange"
          />
        </div>
        
        <!-- 操作按钮 -->
        <div class="action-buttons">
          <button @click="refreshAll" class="btn-refresh">
            <RefreshIcon />
            刷新
          </button>
          <button @click="exportDashboard" class="btn-export">
            <ExportIcon />
            导出
          </button>
          <button @click="toggleEdit" class="btn-edit" v-if="canEdit">
            <EditIcon />
            {{ isEditing ? '完成' : '编辑' }}
          </button>
        </div>
      </div>
    </div>
    
    <!-- 仪表板内容 -->
    <div class="dashboard-content" :style="contentStyle">
      <GridLayout
        v-if="config.layout.type === 'grid'"
        :layout="widgetLayouts"
        :col-num="config.layout.columns"
        :row-height="60"
        :is-draggable="isEditing"
        :is-resizable="isEditing"
        :margin="[config.layout.gap, config.layout.gap]"
        @layout-updated="handleLayoutUpdate"
      >
        <GridItem
          v-for="widget in config.widgets"
          :key="widget.id"
          :x="widget.position.x"
          :y="widget.position.y"
          :w="widget.size.width"
          :h="widget.size.height"
          :i="widget.id"
        >
          <WidgetContainer
            :widget="widget"
            :filters="globalFilters"
            :editing="isEditing"
            @update="handleWidgetUpdate"
            @delete="handleWidgetDelete"
          />
        </GridItem>
      </GridLayout>
    </div>
    
    <!-- 添加组件面板 -->
    <WidgetPanel
      v-if="isEditing"
      @add-widget="handleAddWidget"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { GridLayout, GridItem } from 'vue-grid-layout'
import type { DashboardConfig } from '@/types/dashboard'

interface Props {
  config: DashboardConfig
  canEdit?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  canEdit: false
})

const emit = defineEmits<{
  update: [config: DashboardConfig]
  export: [format: string]
}>()

const isEditing = ref(false)
const globalFilters = ref<Record<string, any>>({})

const dashboardClass = computed(() => ({
  'dashboard--editing': isEditing.value,
  'dashboard--responsive': props.config.layout.responsive
}))

const contentStyle = computed(() => ({
  gap: `${props.config.layout.gap}px`
}))

const widgetLayouts = computed(() => 
  props.config.widgets.map(widget => ({
    i: widget.id,
    x: widget.position.x,
    y: widget.position.y,
    w: widget.size.width,
    h: widget.size.height
  }))
)

onMounted(() => {
  // 初始化全局筛选器
  if (props.config.filters) {
    props.config.filters.forEach(filter => {
      globalFilters.value[filter.key] = filter.defaultValue
    })
  }
  
  // 设置自动刷新
  if (props.config.refresh?.enabled) {
    setInterval(() => {
      refreshAll()
    }, props.config.refresh.interval * 1000)
  }
})

function handleFilterChange(filters: Record<string, any>) {
  globalFilters.value = { ...globalFilters.value, ...filters }
}

function refreshAll() {
  // 刷新所有组件
  props.config.widgets.forEach(widget => {
    // 触发组件刷新
  })
}

function exportDashboard() {
  emit('export', 'pdf')
}

function toggleEdit() {
  isEditing.value = !isEditing.value
}

function handleLayoutUpdate(layout: any[]) {
  // 更新组件布局
  const updatedConfig = { ...props.config }
  layout.forEach(item => {
    const widget = updatedConfig.widgets.find(w => w.id === item.i)
    if (widget) {
      widget.position = { x: item.x, y: item.y }
      widget.size = { width: item.w, height: item.h }
    }
  })
  
  emit('update', updatedConfig)
}

function handleWidgetUpdate(widgetId: string, updates: Partial<WidgetConfig>) {
  const updatedConfig = { ...props.config }
  const widget = updatedConfig.widgets.find(w => w.id === widgetId)
  if (widget) {
    Object.assign(widget, updates)
    emit('update', updatedConfig)
  }
}

function handleWidgetDelete(widgetId: string) {
  const updatedConfig = { ...props.config }
  updatedConfig.widgets = updatedConfig.widgets.filter(w => w.id !== widgetId)
  emit('update', updatedConfig)
}

function handleAddWidget(widgetConfig: WidgetConfig) {
  const updatedConfig = { ...props.config }
  updatedConfig.widgets.push(widgetConfig)
  emit('update', updatedConfig)
}
</script>
```

---

**文档版本**: v1.0  
**最后更新**: 2024年8月14日  
**维护团队**: 架构团队  

> 🏗️ **架构说明**: 本文档详细描述了数据分析平台的技术架构，包括分层设计、核心组件、API接口、缓存策略、性能监控和可视化架构等。在实际实施时，请根据具体的业务需求和技术环境进行调整优化。
