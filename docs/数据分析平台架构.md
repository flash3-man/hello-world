# æ•°æ®åˆ†æå¹³å°æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„æ¦‚è§ˆ

### åˆ†å±‚æ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å±•ç¤ºå±‚ (Presentation Layer)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç§»åŠ¨ç«¯APP   â”‚  â”‚ Webç®¡ç†ç«¯   â”‚  â”‚ å¤§å±å±•ç¤º    â”‚        â”‚
â”‚  â”‚ Vue3+Vant   â”‚  â”‚ React+Ant   â”‚  â”‚ DataV       â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ åˆ†ææœåŠ¡    â”‚  â”‚ æŠ¥è¡¨æœåŠ¡    â”‚  â”‚ å‘Šè­¦æœåŠ¡    â”‚        â”‚
â”‚  â”‚ Analysis    â”‚  â”‚ Report      â”‚  â”‚ Alert       â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç”¨æˆ·æœåŠ¡    â”‚  â”‚ æƒé™æœåŠ¡    â”‚  â”‚ é…ç½®æœåŠ¡    â”‚        â”‚
â”‚  â”‚ User        â”‚  â”‚ Auth        â”‚  â”‚ Config      â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®æœåŠ¡å±‚ (Data Service Layer)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ OLAPæŸ¥è¯¢    â”‚  â”‚ å®æ—¶è®¡ç®—    â”‚  â”‚ æœºå™¨å­¦ä¹     â”‚        â”‚
â”‚  â”‚ ClickHouse  â”‚  â”‚ Flink       â”‚  â”‚ MLflow      â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç¼“å­˜æœåŠ¡    â”‚  â”‚ æœç´¢æœåŠ¡    â”‚  â”‚ å›¾æ•°æ®åº“    â”‚        â”‚
â”‚  â”‚ Redis       â”‚  â”‚ Elasticsearchâ”‚ â”‚ Neo4j       â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å­˜å‚¨å±‚ (Storage Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ æ•°æ®ä»“åº“    â”‚  â”‚ æ•°æ®æ¹–      â”‚  â”‚ å…³ç³»æ•°æ®åº“  â”‚        â”‚
â”‚  â”‚ ClickHouse  â”‚  â”‚ HDFS/S3     â”‚  â”‚ MySQL       â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ å®¹å™¨ç¼–æ’    â”‚  â”‚ æœåŠ¡ç½‘æ ¼    â”‚  â”‚ ç›‘æ§å‘Šè­¦    â”‚        â”‚
â”‚  â”‚ Kubernetes  â”‚  â”‚ Istio       â”‚  â”‚ Prometheus  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. åˆ†æå¼•æ“æ¶æ„

#### OLAPæŸ¥è¯¢å¼•æ“
```yaml
# ClickHouseé›†ç¾¤é…ç½®
clickhouse_cluster:
  name: "business_analysis_cluster"
  nodes:
    - host: "clickhouse-01"
      port: 9000
      role: "shard1_replica1"
    - host: "clickhouse-02"
      port: 9000
      role: "shard1_replica2"
    - host: "clickhouse-03"
      port: 9000
      role: "shard2_replica1"
    - host: "clickhouse-04"
      port: 9000
      role: "shard2_replica2"
  
  settings:
    max_memory_usage: "10000000000"  # 10GB
    max_execution_time: 300          # 5åˆ†é’Ÿ
    max_concurrent_queries: 100
    
  optimization:
    enable_parallel_processing: true
    enable_distributed_aggregation: true
    enable_query_cache: true
    cache_size: "5GB"
```

#### å®æ—¶è®¡ç®—å¼•æ“
```yaml
# Flinké›†ç¾¤é…ç½®
flink_cluster:
  jobmanager:
    replicas: 2
    memory: "2048m"
    cpu: "1000m"
  
  taskmanager:
    replicas: 6
    memory: "4096m"
    cpu: "2000m"
    slots: 4
  
  checkpointing:
    interval: 60000
    timeout: 600000
    min_pause_between: 5000
    max_concurrent: 1
    
  state_backend:
    type: "rocksdb"
    incremental: true
    
  jobs:
    - name: "realtime_sales_aggregation"
      parallelism: 12
      source: "kafka_sales_events"
      sink: "clickhouse_rt_metrics"
    
    - name: "realtime_alert_detection"
      parallelism: 6
      source: "kafka_business_events"
      sink: "alert_notification_service"
```

### 2. æ•°æ®æœåŠ¡APIè®¾è®¡

#### æŸ¥è¯¢æœåŠ¡æ¥å£
```java
/**
 * æ•°æ®æŸ¥è¯¢æœåŠ¡
 */
@RestController
@RequestMapping("/api/v1/query")
@Slf4j
public class DataQueryController {
    
    @Autowired
    private AnalyticsQueryService queryService;
    
    /**
     * å¤šç»´åˆ†ææŸ¥è¯¢
     */
    @PostMapping("/multidimensional")
    public Result<QueryResult> multidimensionalQuery(@RequestBody QueryRequest request) {
        log.info("æ‰§è¡Œå¤šç»´åˆ†ææŸ¥è¯¢: {}", request);
        
        // å‚æ•°éªŒè¯
        validateQueryRequest(request);
        
        // æŸ¥è¯¢ä¼˜åŒ–
        QueryPlan optimizedPlan = queryService.optimizeQuery(request);
        
        // æ‰§è¡ŒæŸ¥è¯¢
        QueryResult result = queryService.executeQuery(optimizedPlan);
        
        // ç»“æœç¼“å­˜
        cacheQueryResult(request, result);
        
        return Result.success(result);
    }
    
    /**
     * å®æ—¶æŒ‡æ ‡æŸ¥è¯¢
     */
    @GetMapping("/realtime/{metricType}")
    public Result<RealtimeMetrics> getRealtimeMetrics(
            @PathVariable String metricType,
            @RequestParam(defaultValue = "1h") String timeWindow) {
        
        log.info("æŸ¥è¯¢å®æ—¶æŒ‡æ ‡: {}, æ—¶é—´çª—å£: {}", metricType, timeWindow);
        
        RealtimeMetrics metrics = queryService.getRealtimeMetrics(metricType, timeWindow);
        
        return Result.success(metrics);
    }
    
    /**
     * è¶‹åŠ¿åˆ†ææŸ¥è¯¢
     */
    @PostMapping("/trend")
    public Result<TrendAnalysisResult> trendAnalysis(@RequestBody TrendQueryRequest request) {
        log.info("æ‰§è¡Œè¶‹åŠ¿åˆ†æ: {}", request);
        
        // æ—¶é—´åºåˆ—åˆ†æ
        TrendAnalysisResult result = queryService.analyzeTrend(request);
        
        return Result.success(result);
    }
}

/**
 * æŸ¥è¯¢è¯·æ±‚æ¨¡å‹
 */
@Data
public class QueryRequest {
    private String queryType;           // æŸ¥è¯¢ç±»å‹
    private List<String> dimensions;    // ç»´åº¦å­—æ®µ
    private List<String> metrics;       // æŒ‡æ ‡å­—æ®µ
    private List<FilterCondition> filters; // è¿‡æ»¤æ¡ä»¶
    private List<SortCondition> sorts;  // æ’åºæ¡ä»¶
    private TimeRange timeRange;        // æ—¶é—´èŒƒå›´
    private Integer limit;              // ç»“æœé™åˆ¶
    private Boolean enableCache;        // æ˜¯å¦å¯ç”¨ç¼“å­˜
}

/**
 * æŸ¥è¯¢ç»“æœæ¨¡å‹
 */
@Data
public class QueryResult {
    private List<Map<String, Object>> data;    // æŸ¥è¯¢æ•°æ®
    private QueryMetadata metadata;            // æŸ¥è¯¢å…ƒæ•°æ®
    private Long totalCount;                   // æ€»è®°å½•æ•°
    private Long executionTime;                // æ‰§è¡Œæ—¶é—´(ms)
    private String queryId;                    // æŸ¥è¯¢ID
    private Boolean fromCache;                 // æ˜¯å¦æ¥è‡ªç¼“å­˜
}
```

#### åˆ†ææœåŠ¡å®ç°
```java
/**
 * åˆ†ææŸ¥è¯¢æœåŠ¡å®ç°
 */
@Service
@Slf4j
public class AnalyticsQueryServiceImpl implements AnalyticsQueryService {
    
    @Autowired
    private ClickHouseTemplate clickHouseTemplate;
    
    @Autowired
    private QueryOptimizer queryOptimizer;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public QueryResult executeQuery(QueryPlan queryPlan) {
        String sql = queryPlan.getSql();
        Map<String, Object> parameters = queryPlan.getParameters();
        
        log.debug("æ‰§è¡ŒSQLæŸ¥è¯¢: {}", sql);
        
        long startTime = System.currentTimeMillis();
        
        try {
            // æ‰§è¡ŒæŸ¥è¯¢
            List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql, parameters);
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            // æ„å»ºæŸ¥è¯¢ç»“æœ
            QueryResult result = QueryResult.builder()
                .data(data)
                .totalCount((long) data.size())
                .executionTime(executionTime)
                .queryId(UUID.randomUUID().toString())
                .fromCache(false)
                .build();
            
            log.info("æŸ¥è¯¢æ‰§è¡Œå®Œæˆï¼Œè€—æ—¶: {}msï¼Œè¿”å›è®°å½•æ•°: {}", executionTime, data.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("æŸ¥è¯¢æ‰§è¡Œå¤±è´¥: {}", e.getMessage(), e);
            throw new BusinessException(ErrorCode.QUERY_EXECUTION_ERROR, "æŸ¥è¯¢æ‰§è¡Œå¤±è´¥");
        }
    }
    
    @Override
    public RealtimeMetrics getRealtimeMetrics(String metricType, String timeWindow) {
        String cacheKey = String.format("realtime:%s:%s", metricType, timeWindow);
        
        // å°è¯•ä»ç¼“å­˜è·å–
        RealtimeMetrics cached = cacheManager.get(cacheKey, RealtimeMetrics.class);
        if (cached != null) {
            return cached;
        }
        
        // ä»å®æ—¶æ•°æ®æºæŸ¥è¯¢
        String sql = buildRealtimeMetricsSql(metricType, timeWindow);
        List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql);
        
        RealtimeMetrics metrics = convertToRealtimeMetrics(data, metricType);
        
        // ç¼“å­˜ç»“æœï¼ˆçŸ­æœŸç¼“å­˜ï¼‰
        cacheManager.put(cacheKey, metrics, Duration.ofMinutes(1));
        
        return metrics;
    }
    
    @Override
    public TrendAnalysisResult analyzeTrend(TrendQueryRequest request) {
        // æ„å»ºè¶‹åŠ¿åˆ†æSQL
        String sql = buildTrendAnalysisSql(request);
        
        List<Map<String, Object>> data = clickHouseTemplate.queryForList(sql);
        
        // æ—¶é—´åºåˆ—åˆ†æ
        TimeSeriesAnalyzer analyzer = new TimeSeriesAnalyzer();
        TrendAnalysisResult result = analyzer.analyze(data, request);
        
        return result;
    }
    
    private String buildRealtimeMetricsSql(String metricType, String timeWindow) {
        switch (metricType) {
            case "sales":
                return String.format("""
                    SELECT 
                        toStartOfInterval(event_time, INTERVAL %s) as time_bucket,
                        sum(amount) as total_amount,
                        count() as event_count,
                        uniq(customer_id) as unique_customers
                    FROM rt_sales_events
                    WHERE event_time >= now() - INTERVAL %s
                    GROUP BY time_bucket
                    ORDER BY time_bucket
                    """, timeWindow, timeWindow);
                    
            case "orders":
                return String.format("""
                    SELECT 
                        toStartOfInterval(event_time, INTERVAL %s) as time_bucket,
                        count() as order_count,
                        sum(order_amount) as total_amount,
                        avg(order_amount) as avg_amount
                    FROM rt_order_events
                    WHERE event_time >= now() - INTERVAL %s
                    GROUP BY time_bucket
                    ORDER BY time_bucket
                    """, timeWindow, timeWindow);
                    
            default:
                throw new BusinessException(ErrorCode.INVALID_METRIC_TYPE, "ä¸æ”¯æŒçš„æŒ‡æ ‡ç±»å‹: " + metricType);
        }
    }
}
```

### 3. ç¼“å­˜ç­–ç•¥è®¾è®¡

#### å¤šçº§ç¼“å­˜æ¶æ„
```java
/**
 * å¤šçº§ç¼“å­˜ç®¡ç†å™¨
 */
@Component
@Slf4j
public class MultiLevelCacheManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final Cache<String, Object> localCache;
    
    public MultiLevelCacheManager() {
        // æœ¬åœ°ç¼“å­˜é…ç½®
        this.localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(Duration.ofMinutes(5))
            .recordStats()
            .build();
    }
    
    /**
     * è·å–ç¼“å­˜æ•°æ®
     */
    public <T> T get(String key, Class<T> type) {
        // 1. å…ˆæŸ¥æœ¬åœ°ç¼“å­˜
        Object localValue = localCache.getIfPresent(key);
        if (localValue != null) {
            log.debug("å‘½ä¸­æœ¬åœ°ç¼“å­˜: {}", key);
            return type.cast(localValue);
        }
        
        // 2. æŸ¥Redisç¼“å­˜
        Object redisValue = redisTemplate.opsForValue().get(key);
        if (redisValue != null) {
            log.debug("å‘½ä¸­Redisç¼“å­˜: {}", key);
            // å›å†™æœ¬åœ°ç¼“å­˜
            localCache.put(key, redisValue);
            return type.cast(redisValue);
        }
        
        log.debug("ç¼“å­˜æœªå‘½ä¸­: {}", key);
        return null;
    }
    
    /**
     * è®¾ç½®ç¼“å­˜æ•°æ®
     */
    public void put(String key, Object value, Duration expiration) {
        // åŒæ—¶å†™å…¥æœ¬åœ°ç¼“å­˜å’ŒRedis
        localCache.put(key, value);
        redisTemplate.opsForValue().set(key, value, expiration);
        
        log.debug("è®¾ç½®ç¼“å­˜: {}, è¿‡æœŸæ—¶é—´: {}", key, expiration);
    }
    
    /**
     * åˆ é™¤ç¼“å­˜
     */
    public void evict(String key) {
        localCache.invalidate(key);
        redisTemplate.delete(key);
        
        log.debug("åˆ é™¤ç¼“å­˜: {}", key);
    }
    
    /**
     * æ‰¹é‡åˆ é™¤ç¼“å­˜
     */
    public void evictByPattern(String pattern) {
        // åˆ é™¤Redisä¸­åŒ¹é…çš„key
        Set<String> keys = redisTemplate.keys(pattern);
        if (!keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
        
        // æ¸…ç©ºæœ¬åœ°ç¼“å­˜ï¼ˆç®€å•å¤„ç†ï¼‰
        localCache.invalidateAll();
        
        log.debug("æ‰¹é‡åˆ é™¤ç¼“å­˜ï¼Œæ¨¡å¼: {}, åˆ é™¤æ•°é‡: {}", pattern, keys.size());
    }
}

/**
 * æŸ¥è¯¢ç»“æœç¼“å­˜ç­–ç•¥
 */
@Component
public class QueryCacheStrategy {
    
    @Autowired
    private MultiLevelCacheManager cacheManager;
    
    /**
     * ç”Ÿæˆç¼“å­˜key
     */
    public String generateCacheKey(QueryRequest request) {
        // ä½¿ç”¨æŸ¥è¯¢å‚æ•°çš„hashä½œä¸ºç¼“å­˜key
        String content = JSON.toJSONString(request);
        return "query:" + DigestUtils.md5Hex(content);
    }
    
    /**
     * ç¡®å®šç¼“å­˜è¿‡æœŸæ—¶é—´
     */
    public Duration determineCacheExpiration(QueryRequest request) {
        // æ ¹æ®æŸ¥è¯¢ç±»å‹å’Œæ—¶é—´èŒƒå›´ç¡®å®šç¼“å­˜æ—¶é—´
        if (request.getTimeRange().isRealtime()) {
            return Duration.ofMinutes(1);  // å®æ—¶æŸ¥è¯¢ç¼“å­˜1åˆ†é’Ÿ
        } else if (request.getTimeRange().isToday()) {
            return Duration.ofMinutes(10); // å½“æ—¥æŸ¥è¯¢ç¼“å­˜10åˆ†é’Ÿ
        } else if (request.getTimeRange().isHistorical()) {
            return Duration.ofHours(1);    // å†å²æŸ¥è¯¢ç¼“å­˜1å°æ—¶
        } else {
            return Duration.ofMinutes(30); // é»˜è®¤ç¼“å­˜30åˆ†é’Ÿ
        }
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥ç¼“å­˜
     */
    public boolean shouldCache(QueryRequest request, QueryResult result) {
        // æŸ¥è¯¢æ—¶é—´è¶…è¿‡1ç§’çš„ç»“æœæ‰ç¼“å­˜
        if (result.getExecutionTime() < 1000) {
            return false;
        }
        
        // ç»“æœé›†å¤ªå¤§ä¸ç¼“å­˜
        if (result.getTotalCount() > 10000) {
            return false;
        }
        
        // å®æ—¶æŸ¥è¯¢ä¸ç¼“å­˜
        if (request.getQueryType().equals("realtime")) {
            return false;
        }
        
        return true;
    }
}
```

### 4. æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

#### æŸ¥è¯¢æ€§èƒ½ç›‘æ§
```java
/**
 * æŸ¥è¯¢æ€§èƒ½ç›‘æ§
 */
@Component
@Slf4j
public class QueryPerformanceMonitor {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    private final Timer queryTimer;
    private final Counter queryCounter;
    private final Gauge slowQueryGauge;
    
    public QueryPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.queryTimer = Timer.builder("query.execution.time")
            .description("æŸ¥è¯¢æ‰§è¡Œæ—¶é—´")
            .register(meterRegistry);
        this.queryCounter = Counter.builder("query.total")
            .description("æŸ¥è¯¢æ€»æ•°")
            .register(meterRegistry);
        this.slowQueryGauge = Gauge.builder("query.slow.count")
            .description("æ…¢æŸ¥è¯¢æ•°é‡")
            .register(meterRegistry, this, QueryPerformanceMonitor::getSlowQueryCount);
    }
    
    /**
     * è®°å½•æŸ¥è¯¢æ€§èƒ½
     */
    public void recordQueryPerformance(String queryType, long executionTime, boolean success) {
        // è®°å½•æŸ¥è¯¢æ—¶é—´
        queryTimer.record(executionTime, TimeUnit.MILLISECONDS);
        
        // è®°å½•æŸ¥è¯¢æ¬¡æ•°
        queryCounter.increment(
            Tags.of(
                "type", queryType,
                "status", success ? "success" : "failure"
            )
        );
        
        // è®°å½•æ…¢æŸ¥è¯¢
        if (executionTime > 5000) { // è¶…è¿‡5ç§’çš„æŸ¥è¯¢
            recordSlowQuery(queryType, executionTime);
        }
        
        log.info("æŸ¥è¯¢æ€§èƒ½è®°å½• - ç±»å‹: {}, è€—æ—¶: {}ms, çŠ¶æ€: {}", 
            queryType, executionTime, success ? "æˆåŠŸ" : "å¤±è´¥");
    }
    
    private void recordSlowQuery(String queryType, long executionTime) {
        // è®°å½•æ…¢æŸ¥è¯¢åˆ°æ•°æ®åº“æˆ–æ—¥å¿—
        log.warn("æ…¢æŸ¥è¯¢å‘Šè­¦ - ç±»å‹: {}, è€—æ—¶: {}ms", queryType, executionTime);
        
        // å‘é€å‘Šè­¦
        sendSlowQueryAlert(queryType, executionTime);
    }
    
    private void sendSlowQueryAlert(String queryType, long executionTime) {
        // å‘é€å‘Šè­¦é€šçŸ¥
        AlertMessage alert = AlertMessage.builder()
            .title("æ…¢æŸ¥è¯¢å‘Šè­¦")
            .content(String.format("æŸ¥è¯¢ç±»å‹: %s, æ‰§è¡Œæ—¶é—´: %dms", queryType, executionTime))
            .level(AlertLevel.WARNING)
            .build();
            
        alertService.sendAlert(alert);
    }
    
    private double getSlowQueryCount() {
        // è¿”å›æœ€è¿‘1å°æ—¶çš„æ…¢æŸ¥è¯¢æ•°é‡
        return slowQueryRepository.countByTimeRange(
            LocalDateTime.now().minusHours(1),
            LocalDateTime.now()
        );
    }
}
```

## ğŸ“Š æ•°æ®å¯è§†åŒ–æ¶æ„

### 1. å›¾è¡¨ç»„ä»¶è®¾è®¡

#### é€šç”¨å›¾è¡¨é…ç½®
```typescript
// å›¾è¡¨é…ç½®æ¥å£
interface ChartConfig {
  type: ChartType;
  title: string;
  data: ChartData;
  options: ChartOptions;
  interactions?: ChartInteraction[];
}

// å›¾è¡¨ç±»å‹æšä¸¾
enum ChartType {
  LINE = 'line',
  BAR = 'bar',
  PIE = 'pie',
  SCATTER = 'scatter',
  HEATMAP = 'heatmap',
  GAUGE = 'gauge',
  FUNNEL = 'funnel',
  RADAR = 'radar'
}

// å›¾è¡¨æ•°æ®ç»“æ„
interface ChartData {
  dimensions: string[];
  measures: string[];
  dataset: Record<string, any>[];
  aggregations?: Aggregation[];
}

// å›¾è¡¨é€‰é¡¹
interface ChartOptions {
  width?: number;
  height?: number;
  theme?: string;
  animation?: boolean;
  responsive?: boolean;
  legend?: LegendConfig;
  tooltip?: TooltipConfig;
  axis?: AxisConfig;
  colors?: string[];
}
```

#### å›¾è¡¨ç»„ä»¶å®ç°
```vue
<!-- é€šç”¨å›¾è¡¨ç»„ä»¶ -->
<template>
  <div class="chart-container" :style="containerStyle">
    <div class="chart-header" v-if="config.title">
      <h3 class="chart-title">{{ config.title }}</h3>
      <div class="chart-actions">
        <button @click="refreshChart" class="action-btn">
          <RefreshIcon />
        </button>
        <button @click="exportChart" class="action-btn">
          <DownloadIcon />
        </button>
        <button @click="fullscreen" class="action-btn">
          <FullscreenIcon />
        </button>
      </div>
    </div>
    
    <div 
      ref="chartRef" 
      class="chart-content"
      :style="chartStyle"
    ></div>
    
    <div class="chart-loading" v-if="loading">
      <LoadingSpinner />
      <span>æ•°æ®åŠ è½½ä¸­...</span>
    </div>
    
    <div class="chart-error" v-if="error">
      <ErrorIcon />
      <span>{{ error }}</span>
      <button @click="retryLoad" class="retry-btn">é‡è¯•</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, computed } from 'vue'
import * as echarts from 'echarts'
import type { ChartConfig } from '@/types/chart'

interface Props {
  config: ChartConfig
  loading?: boolean
  error?: string
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  error: ''
})

const emit = defineEmits<{
  refresh: []
  export: [format: string]
  interact: [event: any]
}>()

const chartRef = ref<HTMLElement>()
const chartInstance = ref<echarts.ECharts>()

const containerStyle = computed(() => ({
  width: props.config.options?.width ? `${props.config.options.width}px` : '100%',
  height: props.config.options?.height ? `${props.config.options.height}px` : '400px'
}))

const chartStyle = computed(() => ({
  width: '100%',
  height: props.config.title ? 'calc(100% - 40px)' : '100%'
}))

onMounted(() => {
  initChart()
})

watch(() => props.config, () => {
  updateChart()
}, { deep: true })

function initChart() {
  if (!chartRef.value) return
  
  chartInstance.value = echarts.init(chartRef.value, props.config.options?.theme)
  
  // æ·»åŠ äº¤äº’äº‹ä»¶
  chartInstance.value.on('click', (params) => {
    emit('interact', { type: 'click', params })
  })
  
  chartInstance.value.on('legendselectchanged', (params) => {
    emit('interact', { type: 'legendChange', params })
  })
  
  updateChart()
}

function updateChart() {
  if (!chartInstance.value) return
  
  const option = buildChartOption(props.config)
  chartInstance.value.setOption(option, true)
}

function buildChartOption(config: ChartConfig) {
  const baseOption = {
    title: {
      text: config.title,
      left: 'center'
    },
    tooltip: {
      trigger: 'axis',
      ...config.options?.tooltip
    },
    legend: {
      type: 'scroll',
      bottom: 0,
      ...config.options?.legend
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '10%',
      containLabel: true
    },
    animation: config.options?.animation !== false
  }
  
  // æ ¹æ®å›¾è¡¨ç±»å‹æ„å»ºç‰¹å®šé…ç½®
  switch (config.type) {
    case ChartType.LINE:
      return buildLineChartOption(config, baseOption)
    case ChartType.BAR:
      return buildBarChartOption(config, baseOption)
    case ChartType.PIE:
      return buildPieChartOption(config, baseOption)
    default:
      return baseOption
  }
}

function buildLineChartOption(config: ChartConfig, baseOption: any) {
  return {
    ...baseOption,
    xAxis: {
      type: 'category',
      data: config.data.dimensions,
      ...config.options?.axis?.x
    },
    yAxis: {
      type: 'value',
      ...config.options?.axis?.y
    },
    series: config.data.measures.map(measure => ({
      name: measure,
      type: 'line',
      data: config.data.dataset.map(item => item[measure]),
      smooth: true,
      symbol: 'circle',
      symbolSize: 6
    }))
  }
}

function refreshChart() {
  emit('refresh')
}

function exportChart() {
  if (!chartInstance.value) return
  
  const dataURL = chartInstance.value.getDataURL({
    type: 'png',
    pixelRatio: 2,
    backgroundColor: '#fff'
  })
  
  emit('export', dataURL)
}

function fullscreen() {
  // å…¨å±æ˜¾ç¤ºé€»è¾‘
}

function retryLoad() {
  emit('refresh')
}
</script>
```

### 2. ä»ªè¡¨æ¿è®¾è®¡

#### ä»ªè¡¨æ¿é…ç½®
```typescript
// ä»ªè¡¨æ¿é…ç½®
interface DashboardConfig {
  id: string
  name: string
  description?: string
  layout: LayoutConfig
  widgets: WidgetConfig[]
  filters?: FilterConfig[]
  refresh?: RefreshConfig
  permissions?: PermissionConfig
}

// å¸ƒå±€é…ç½®
interface LayoutConfig {
  type: 'grid' | 'flex' | 'absolute'
  columns: number
  gap: number
  responsive: boolean
}

// ç»„ä»¶é…ç½®
interface WidgetConfig {
  id: string
  type: WidgetType
  title: string
  position: Position
  size: Size
  dataSource: DataSourceConfig
  chartConfig: ChartConfig
  interactions?: InteractionConfig[]
}

// æ•°æ®æºé…ç½®
interface DataSourceConfig {
  type: 'api' | 'websocket' | 'static'
  url?: string
  method?: string
  params?: Record<string, any>
  headers?: Record<string, string>
  refresh?: number // åˆ·æ–°é—´éš”(ç§’)
}
```

#### ä»ªè¡¨æ¿ç»„ä»¶
```vue
<!-- ä»ªè¡¨æ¿ç»„ä»¶ -->
<template>
  <div class="dashboard" :class="dashboardClass">
    <!-- ä»ªè¡¨æ¿å¤´éƒ¨ -->
    <div class="dashboard-header">
      <div class="dashboard-title">
        <h2>{{ config.name }}</h2>
        <p v-if="config.description">{{ config.description }}</p>
      </div>
      
      <div class="dashboard-actions">
        <!-- å…¨å±€ç­›é€‰å™¨ -->
        <div class="global-filters" v-if="config.filters">
          <FilterPanel 
            :filters="config.filters"
            @change="handleFilterChange"
          />
        </div>
        
        <!-- æ“ä½œæŒ‰é’® -->
        <div class="action-buttons">
          <button @click="refreshAll" class="btn-refresh">
            <RefreshIcon />
            åˆ·æ–°
          </button>
          <button @click="exportDashboard" class="btn-export">
            <ExportIcon />
            å¯¼å‡º
          </button>
          <button @click="toggleEdit" class="btn-edit" v-if="canEdit">
            <EditIcon />
            {{ isEditing ? 'å®Œæˆ' : 'ç¼–è¾‘' }}
          </button>
        </div>
      </div>
    </div>
    
    <!-- ä»ªè¡¨æ¿å†…å®¹ -->
    <div class="dashboard-content" :style="contentStyle">
      <GridLayout
        v-if="config.layout.type === 'grid'"
        :layout="widgetLayouts"
        :col-num="config.layout.columns"
        :row-height="60"
        :is-draggable="isEditing"
        :is-resizable="isEditing"
        :margin="[config.layout.gap, config.layout.gap]"
        @layout-updated="handleLayoutUpdate"
      >
        <GridItem
          v-for="widget in config.widgets"
          :key="widget.id"
          :x="widget.position.x"
          :y="widget.position.y"
          :w="widget.size.width"
          :h="widget.size.height"
          :i="widget.id"
        >
          <WidgetContainer
            :widget="widget"
            :filters="globalFilters"
            :editing="isEditing"
            @update="handleWidgetUpdate"
            @delete="handleWidgetDelete"
          />
        </GridItem>
      </GridLayout>
    </div>
    
    <!-- æ·»åŠ ç»„ä»¶é¢æ¿ -->
    <WidgetPanel
      v-if="isEditing"
      @add-widget="handleAddWidget"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { GridLayout, GridItem } from 'vue-grid-layout'
import type { DashboardConfig } from '@/types/dashboard'

interface Props {
  config: DashboardConfig
  canEdit?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  canEdit: false
})

const emit = defineEmits<{
  update: [config: DashboardConfig]
  export: [format: string]
}>()

const isEditing = ref(false)
const globalFilters = ref<Record<string, any>>({})

const dashboardClass = computed(() => ({
  'dashboard--editing': isEditing.value,
  'dashboard--responsive': props.config.layout.responsive
}))

const contentStyle = computed(() => ({
  gap: `${props.config.layout.gap}px`
}))

const widgetLayouts = computed(() => 
  props.config.widgets.map(widget => ({
    i: widget.id,
    x: widget.position.x,
    y: widget.position.y,
    w: widget.size.width,
    h: widget.size.height
  }))
)

onMounted(() => {
  // åˆå§‹åŒ–å…¨å±€ç­›é€‰å™¨
  if (props.config.filters) {
    props.config.filters.forEach(filter => {
      globalFilters.value[filter.key] = filter.defaultValue
    })
  }
  
  // è®¾ç½®è‡ªåŠ¨åˆ·æ–°
  if (props.config.refresh?.enabled) {
    setInterval(() => {
      refreshAll()
    }, props.config.refresh.interval * 1000)
  }
})

function handleFilterChange(filters: Record<string, any>) {
  globalFilters.value = { ...globalFilters.value, ...filters }
}

function refreshAll() {
  // åˆ·æ–°æ‰€æœ‰ç»„ä»¶
  props.config.widgets.forEach(widget => {
    // è§¦å‘ç»„ä»¶åˆ·æ–°
  })
}

function exportDashboard() {
  emit('export', 'pdf')
}

function toggleEdit() {
  isEditing.value = !isEditing.value
}

function handleLayoutUpdate(layout: any[]) {
  // æ›´æ–°ç»„ä»¶å¸ƒå±€
  const updatedConfig = { ...props.config }
  layout.forEach(item => {
    const widget = updatedConfig.widgets.find(w => w.id === item.i)
    if (widget) {
      widget.position = { x: item.x, y: item.y }
      widget.size = { width: item.w, height: item.h }
    }
  })
  
  emit('update', updatedConfig)
}

function handleWidgetUpdate(widgetId: string, updates: Partial<WidgetConfig>) {
  const updatedConfig = { ...props.config }
  const widget = updatedConfig.widgets.find(w => w.id === widgetId)
  if (widget) {
    Object.assign(widget, updates)
    emit('update', updatedConfig)
  }
}

function handleWidgetDelete(widgetId: string) {
  const updatedConfig = { ...props.config }
  updatedConfig.widgets = updatedConfig.widgets.filter(w => w.id !== widgetId)
  emit('update', updatedConfig)
}

function handleAddWidget(widgetConfig: WidgetConfig) {
  const updatedConfig = { ...props.config }
  updatedConfig.widgets.push(widgetConfig)
  emit('update', updatedConfig)
}
</script>
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024å¹´8æœˆ14æ—¥  
**ç»´æŠ¤å›¢é˜Ÿ**: æ¶æ„å›¢é˜Ÿ  

> ğŸ—ï¸ **æ¶æ„è¯´æ˜**: æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†æ•°æ®åˆ†æå¹³å°çš„æŠ€æœ¯æ¶æ„ï¼ŒåŒ…æ‹¬åˆ†å±‚è®¾è®¡ã€æ ¸å¿ƒç»„ä»¶ã€APIæ¥å£ã€ç¼“å­˜ç­–ç•¥ã€æ€§èƒ½ç›‘æ§å’Œå¯è§†åŒ–æ¶æ„ç­‰ã€‚åœ¨å®é™…å®æ–½æ—¶ï¼Œè¯·æ ¹æ®å…·ä½“çš„ä¸šåŠ¡éœ€æ±‚å’ŒæŠ€æœ¯ç¯å¢ƒè¿›è¡Œè°ƒæ•´ä¼˜åŒ–ã€‚
